<!DOCTYPE html>
<html id="Start" lang='en'>
<head>
	<meta charset="UTF-8">
	<title>Java for Myself</title>
	<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0/css/bootstrap.css'>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
    <div id="gridcontainer">
        <div id="h-container">
			<div><h1>Java is so Weird. </h1></div>	
		</div>
		<div id="n-container">
			<nav id="navbar">
				<ul clas="currentnav">
					<header></header>
					<a class="nav-link first" href="#OOP" rel="internal"><li>OOP</li></a>
					<a class="nav-link" href="#Interface" rel="internal"><li>Interface</li></a>
					<a class="nav-link" href="#ArrayList" rel="internal"><li>ArrayList</li></a>
					<a class="nav-link" href="#HashSet" rel="internal"><li>HashSet</li></a>
				</ul>
			</nav>
		</div>
		<div id="m-container">
			<main id="main-doc">
				<section class="main-section" id="OOP" name="OOP">
					<header><h2>OOP</h2></header>
					<p>Java is a programming language based on object oriented model. Everything should be in a class.
						<br>Everything in Java is taken as an object. Object is something with state and behavior. For example, student is an object, it has age and grade and states, eat and move as behaviors. <br>
					</p>
					<p>Advantages:</p>
              		<ul>
                		<li>Abstraction</li>
		                <li>Encapsulation</li>
		                <li>Inheritance</li>
		                <li>Polymorphism</li>
		            </ul>
				</section>
				<section class="main-section" id="Interface" name="Interface">
					<header><h2>Interface and Abstract class</h2></header>
					<p>Abstract class fulfills Polymorphism, so is interface. Sometimes abstract class is not enough, because one class cannot inherit multiple class. For example, if we need method Hunt() for class Tiger, but it cannot be added to Mammal class, since Goat do not hunt. Tiger needs to implement Hunt() from somewhere else, which is interface.</p>
					<blockquote><code>interface Huntable{
	public void hunt(Animal a);
}
// define the father abstract class
// we only define the name of the methods, not the body
abstract class Animal{
	public abstract String getName();
	public abstract void move(String destination);
	public abstract void drink();
}
// define a sub abstract class, which inherit Animal
abstract class Mammal extends Animal{
	// inherit all methods from Animal;
	// you can also add new methods here 
	public abstract void feedChildren();
}
// define another sub abstract class
abstract class Reptile extends Animal{
	// inherit all methods from Animal;
	// you can also add new methods here;
}
</code></blockquote>
<P>Define a class Tiger. it has to rewrite all the abstract methods from the super class</P>
<blockquote><code>class Tiger extends Mammal implements Huntable{
	private static String name = "Tiger";
	public String getName(){
		return this.name;
	}
	public void move(String destination){
		System.out.println("A tiger runs to " + destination + ".");
	}
	public void drink(){
		System.out.println("A tiger drinks water");
	}
	public void feedChildren(){
		System.out.println("Tigers breastfeeds.");
	}
	public void hunt(Animal a){
		System.out.println("Tiger caught a " + a.getName() + " and ate it.");
	}
}
</code></blockquote>
<P>Define another class goat. it also extends mammal </P>
<blockquote><code>class Goat extends Mammal{
		private static String name = "Goat";
	public String getName(){
		return this.name;
	}
	public void move(String destination){
		System.out.println("A goat runs to " + destination + ".");
	}
	public void drink(){
		System.out.println("A goat drinks water");
	}
	public void feedChildren(){
		System.out.println("Goats breastfeeds.");
	}
}
class Snake extends Reptile implements Huntable{
	private static String name = "Snake";
	public String getName(){
		return this.name;
	}
	public void move(String destination){
		System.out.println("A Snake crawls to " + destination + ".");
	}
	public void drink(){
		System.out.println("A snake drinks water. ");
	}
	public void hunt(Animal a){
		System.out.println("A Snake caught a " + a.getName() + " and ate it.");
	}
// that's it. because snake extends Reptile, no feedChildren method in Reptile;
}
</code></blockquote>
<P>Create a farmer class</P>
<blockquote><code>class Farmer{
	public void bringWater(String destination){
		System.out.println("A farmer brings water to " + destination + ".");
	}
	public void bringAnimal(Animal a){
		System.out.println("A farmer brings " + a.getName() + " to the feeding room.");
	}
	public void feedWater(Animal a){
		this.bringWater("feeding room");
		a.move("feeding room");
		a.drink();
	}
	public void feedAnimal(Animal ht, Animal ct){
		this.bringAnimal(ct);
		ht.move("Feeding room. ");
		// an interface will allow all class to implement it. 
		Huntable htb = (Huntable) ht;  
		htb.hunt(ct);
	}
}
</code></blockquote>

<blockquote><code>class interfaceDemo{
	public static void main(String[] args){
		Farmer fm = new Farmer();
		Snake sn = new Snake();
		Goat gt = new Goat();
		Tiger tg = new Tiger();
		fm.feedWater(sn); 
		// the input of this function belongs to Animal abstract class 
		// fm.feedWater(gt);
		// tg.feedChildren();
		fm.feedAnimal(tg, gt);
	}
}
</code></blockquote>

				</section>



				<section class="main-section" id="ArrayList" name="ArrayList">
				<header><h2>List and ArrayList</h2></header>
				<p><span style="color: red">ArrayList</span> is a class, while <span style="color: #99cc00">List</span> is an interface. ArrayList is a resizable array, which can be found in the java.util package. List cannot be constructed, because it is an interface, while ArrayList can, because it is a class. <br><span style="color: red">ArrayList</span> implements <span style="color: #99cc00">List</span>. <span style="color: #99cc00">List</span> is an Interface, which extends <span style="color: #99cc00">Collection</span>. <span style="color: #99cc00">Collection</span> is an Interface, which extends <span style="color: #99cc00">Interable</span> Interface.
				</p>
<p>This creates an instance of List with ArrayList constructor. This list object only has the states and methods from List. If there is a method implemented by ArrayList but not List, then list will not have it. 
</p>			
<blockquote><code>List&lt;Integer&gt; list = new ArrayListt&lt;Integer&gt;();</code>
</blockquote>
<p>Why List list, instead of ArrayList list? Classes like LinkedList, Vector, and ArrayList, they all implement List interface. If we change the ArrayList to LinkedList in the future, we don't need to change all the codes, except for the construction line. </p>

<blockquote><code>import java.util.ArrayList;

// &#x2757;Creating an ArrayList from another collection 
<span style="color: red">// int[] will not work, it has to be a collection</span>
ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
ArrayList&lt;Integer&gt; anotherArr = new ArrayList&lt;Integer&gt;(arr);

//ArrayList to Array:
List&lt;Integer&gt;

// Adding all elements from an existing collection to the new ArrayList using <span class="func">addAll()</span>

// Array.asList() returns a <span style="color: red">fixed-size</span> list.
// ArrayList.toArray() returns an Object[] array. 
</code>





				</section>
				<section class="main-section" id="HashSet" name="HashSet">
              <header><h2>HashSet & HashMap</h2></header>
              <p>Hashset is an implementation of the Set interface. HashMap implements the Map interface. </p>

              <blockquote>
<code>// create a HashSet using the HashSet() constructor. 
// To initialize a container, you cannot use a primitive type, so we have to use Integer instead of int, and Character instead of char. 

              </blockquote>
            </section>
			</main>
		</div>
		
	</div>
</body>
</html>